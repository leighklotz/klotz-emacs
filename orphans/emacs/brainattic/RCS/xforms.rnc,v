head	1.12;
access;
symbols;
locks; strict;
comment	@# @;


1.12
date	2005.03.23.22.13.37;	author klotz;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.23.19.43.32;	author klotz;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.23.19.42.37;	author klotz;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.23.19.42.21;	author klotz;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.23.19.41.45;	author klotz;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.23.19.39.59;	author klotz;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.23.19.35.18;	author klotz;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.23.19.33.44;	author klotz;	state Exp;
branches;
next	1.4;

1.4
date	2005.03.23.19.32.53;	author klotz;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.23.19.28.08;	author klotz;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.23.00.57.43;	author klotz;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.23.00.56.47;	author klotz;	state Exp;
branches;
next	;


desc
@@


1.12
log
@On Load, change
 attribute resource { xsd:anyURI }?,
 Single.Node.Binding.Attributes?,
to
 (attribute resource { xsd:anyURI } | Single.Node.Binding.Attributes),
to express co-occurence constraint.
@
text
@#  Copyright 2004-2005 Brain Attic, L.L.C.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

default namespace = "http://www.w3.org/2002/xforms"
namespace ev = "http://www.w3.org/2001/xml-events"
namespace xsd = "http://www.w3.org/2001/XMLSchema"
datatypes xsd = "http://www.w3.org/2001/XMLSchema-datatypes"
include "xml-events-2.rnc"

anyElement =  element * { (attribute * { text } | text | anyElement)* }

# Core
Common.Attributes = empty
Linking.Attributes = attribute src { xsd:anyURI }?
## bind and model are IDREFs
Single.Node.Binding.Attributes =  attribute bind { xsd:NCName } | (attribute model { xsd:NCName }?, attribute ref { xsd:string })
## bind and model are IDREFs
Nodeset.Binding.Attributes =  attribute bind { xsd:NCName } | (attribute model { xsd:NCName }?, attribute nodeset { xsd:string })

# Placeholder for XML Schema RNG
Schema = element xsd:schema { (attribute * { text } | text | anyElement)* }

Model = element model { Model.Attributes, Model.Content }
Model.Attributes &=
    Common.Attributes,
    Events.Attributes,
    attribute functions { list { xsd:QName+ }}?,
    attribute schema { list { xsd:anyURI+ }}?
Model.Content = Instance* & Submission* & Bind* & Schema* & Actions*

Instance = element instance { Instance.Attributes, Instance.Content }
Instance.Attributes &=
    Common.Attributes,
    Linking.Attributes
Instance.Content = anyElement?

Submission = element submission { Submission.Attributes, Submission.Content }
## bind is an IDREF
Submission.Attributes &=
    Common.Attributes,
    attribute method { xsd:QName { pattern = "[^:]+:[^:]+" } | "post" | "put" | "get" | "form-data-post" | "urlencoded-post" },
    (attribute bind { xsd:NCName } | attribute ref { xsd:string })?,
    attribute action { xsd:anyURI }?,
    attribute version { xsd:NMTOKEN }?,
    attribute indent { xsd:boolean }?,
    attribute encoding { text }?,
    attribute omit-xml-declaration { xsd:boolean }?,
    attribute standalone { xsd:boolean }?,
    attribute cdata-section-elements { list { xsd:QName+ }}?,
    attribute replace { xsd:QName { pattern = "[^:]+:[^:]+" } | "all" | "instance" | "none" }?,
    attribute separator { ";" | "&" }?
Submission.Content = Actions

Bind = element bind { Bind.Attributes, Bind.Content }
Bind.Attributes &=
    Common.Attributes,
    attribute nodeset { xsd:string }?,
    attribute type { xsd:string }?, #QName
    attribute readonly { xsd:string }?,
    attribute required { xsd:string }?,
    attribute relevant { xsd:string }?,
    attribute constraint { xsd:string }?,
    attribute calculate { xsd:string }?,
    attribute maxOccurs { xsd:string }?,
    attribute minOccurs { xsd:string }?,
    attribute p3ptype { text }?
Bind.Content = Bind*

# Form Controls
UI.Common.Attributes &=
    #host language to add accesskey and navindex here
    attribute appearance { xsd:QName { pattern = "[^:]+:[^:]+" } | "minimal" | "compact" | "full" }?
UI.Inline.Content = (text & Output?)
UI.Common.Content = (Help | Hint | Alert | Actions)*
List.UI.Common.Content = (Item | Itemset | Choices)+

Label.Content = UI.Inline.Content
Label = element label { Common.Attributes & (Linking.Attributes | Single.Node.Binding.Attributes | Label.Content) }
#Label.Attributes &=
#    Common.Attributes,
#    Linking.Attributes?,
#    Single.Node.Binding.Attributes?

Help = element help { Help.Attributes, Help.Content }
Help.Attributes &=
    Common.Attributes,
    Linking.Attributes?,
    Single.Node.Binding.Attributes?
Help.Content = UI.Inline.Content

Hint = element hint { Hint.Attributes, Hint.Content }
Hint.Attributes &=
    Common.Attributes,
    Linking.Attributes?,
    Single.Node.Binding.Attributes?
Hint.Content = UI.Inline.Content

Alert = element alert { Alert.Attributes, Alert.Content }
Alert.Attributes &=
    Common.Attributes,
    Linking.Attributes?,
    Single.Node.Binding.Attributes?
Alert.Content = UI.Inline.Content

Choices =  element choices { Choices.Attributes, Choices.Content }
Choices.Attributes &=
    Common.Attributes
Choices.Content = Label?, (Choices | Item | Itemset)+

Value = element value { Value.Attributes, Value.Content }
Value.Attributes &=
    Common.Attributes,
    Single.Node.Binding.Attributes?
Value.Content =  mixed { anyElement }?

Item = element item { Item.Attributes, Item.Content }
Item.Attributes &=
    Common.Attributes
Item.Content = Label, Value, UI.Common.Content

Itemset = element itemset { Itemset.Attributes, Itemset.Content }
Itemset.Attributes &=
    Common.Attributes,
    Nodeset.Binding.Attributes
Itemset.Content = Label, (Value | Copy), UI.Common.Content

Copy =  element copy { Copy.Attributes, Copy.Content }
Copy.Attributes &=
    Common.Attributes,
    Single.Node.Binding.Attributes
Copy.Content = empty

Filename = element filename { Filename.Attributes, Filename.Content }
Filename.Attributes &=
    Common.Attributes,
    Single.Node.Binding.Attributes
Filename.Content = empty

Mediatype = element mediatype { Mediatype.Attributes, Mediatype.Content }
Mediatype.Attributes &=
    Common.Attributes,
    Single.Node.Binding.Attributes
Mediatype.Content = empty

Output = element output { Output.Attributes, Output.Content }
Output.Attributes &=
    Common.Attributes,
    UI.Common.Attributes,
    Single.Node.Binding.Attributes?,
    attribute value { xsd:string }?
Output.Content = Label?

Input = element input { Input.Attributes, Input.Content }
Input.Attributes &=
    Common.Attributes,
    Single.Node.Binding.Attributes,
    attribute inputmode { text }?,
    UI.Common.Attributes,
    attribute incremental { xsd:boolean }?
Input.Content = Label, UI.Common.Content

Textarea = element textarea { Textarea.Attributes, Textarea.Content }
Textarea.Attributes &=
    Common.Attributes,
    Single.Node.Binding.Attributes,
    attribute inputmode { text }?,
    UI.Common.Attributes,
    attribute incremental { xsd:boolean }?
Textarea.Content = Label, UI.Common.Content

Secret = element secret { Secret.Attributes, Secret.Content }
Secret.Attributes &=
    Common.Attributes,
    Single.Node.Binding.Attributes,
    attribute inputmode { text }?,
    UI.Common.Attributes,
    attribute incremental { xsd:boolean }?
Secret.Content = Label, UI.Common.Content

Upload = element upload { Upload.Attributes, Upload.Content }
Upload.Attributes &=
    Common.Attributes,
    Single.Node.Binding.Attributes,
    attribute mediatype { text }?,
    UI.Common.Attributes,
    attribute incremental { xsd:boolean }?
Upload.Content = Label, Filename?, Mediatype?, UI.Common.Content

Select1 = element select1 { Select1.Attributes, Select1.Content }
Select1.Attributes &=
    Common.Attributes,
    Single.Node.Binding.Attributes,
    UI.Common.Attributes,
    attribute selection { "open" | "closed" }?,
    attribute incremental { xsd:boolean }?
Select1.Content = Label, List.UI.Common.Content, UI.Common.Content

Select = element select { Select.Attributes, Select.Content }
Select.Attributes &=
    Common.Attributes,
    Single.Node.Binding.Attributes,
    UI.Common.Attributes,
    attribute selection { "open" | "closed" }?,
    attribute incremental { xsd:boolean }?
Select.Content = Label, List.UI.Common.Content, UI.Common.Content

Range = element range { Range.Attributes, Range.Content }
Range.Attributes &=
    Common.Attributes,
    Single.Node.Binding.Attributes,
    UI.Common.Attributes,
    attribute start { text }?,
    attribute end { text }?,
    attribute step { text }?,
    attribute incremental { xsd:boolean }?
Range.Content = Label, UI.Common.Content

Trigger = element trigger { Trigger.Attributes, Trigger.Content }
Trigger.Attributes &=
    Common.Attributes,
    Single.Node.Binding.Attributes?,
    UI.Common.Attributes?
Trigger.Content = Label, UI.Common.Content

Submit = element submit { Submit.Attributes, Submit.Content }
## submission is an IDREF
Submit.Attributes &=
    Common.Attributes,
    attribute submission { xsd:NCName },
    Single.Node.Binding.Attributes?,
    UI.Common.Attributes?
Submit.Content = Label, UI.Common.Content

Form.Controls = Input | Textarea | Secret | Output | Upload | Select1 | Select | Range | Submit | Trigger

# Actions
Action = element action { Action.Attributes, Action.Content }
Action.Attributes &=
    Common.Attributes,
    Events.Attributes
Action.Content = Actions

Dispatch = element dispatch { Dispatch.Attributes, Dispatch.Content }
## target is an IDREF
Dispatch.Attributes &=
    Common.Attributes,
    attribute name { xsd:NMTOKEN },
    attribute target { xsd:NCName },
    attribute bubbles { xsd:boolean }?,
    attribute cancelable { xsd:boolean }?,
    Events.Attributes
Dispatch.Content = empty

Rebuild = element rebuild { Rebuild.Attributes, Rebuild.Content }
## model is an IDREF
Rebuild.Attributes &=
    Common.Attributes,
    attribute model { xsd:NCName },
    Events.Attributes
Rebuild.Content = empty

Revalidate = element revalidate { Revalidate.Attributes, Revalidate.Content }
## model is an IDREF
Revalidate.Attributes &=
    Common.Attributes,
    attribute model { xsd:NCName },
    Events.Attributes
Revalidate.Content = empty

Recalculate = element recalculate { Recalculate.Attributes, Recalculate.Content }
## model is an IDREF
Recalculate.Attributes &=
    Common.Attributes,
    attribute model { xsd:NCName },
    Events.Attributes
Recalculate.Content = empty

Refresh = element refresh { Refresh.Attributes, Refresh.Content }
## model is an IDREF
Refresh.Attributes &=
    Common.Attributes,
    attribute model { xsd:NCName },
    Events.Attributes
Refresh.Content = empty

Setfocus = element setfocus { Setfocus.Attributes, Setfocus.Content }
## model is an IDREF
Setfocus.Attributes &=
    Common.Attributes,
    attribute control { xsd:NCName },
    Events.Attributes
Setfocus.Content = empty

Load = element load { Load.Attributes, Load.Content }
Load.Attributes &=
    Common.Attributes,
    (attribute resource { xsd:anyURI } | Single.Node.Binding.Attributes),
    attribute show { "new" | "replace" }?,
    Events.Attributes
Load.Content = empty

Setvalue = element setvalue { Setvalue.Attributes, Setvalue.Content }
Setvalue.Attributes &=
    Common.Attributes,
    Single.Node.Binding.Attributes?,
    attribute value { xsd:string }?,
    Events.Attributes
Setvalue.Content = text

Send = element send { Send.Attributes, Send.Content }
## submission is an IDREF
Send.Attributes &=
    Common.Attributes,
    attribute submission { xsd:NCName },
    Events.Attributes
Send.Content = empty

Reset = element reset { Reset.Attributes, Reset.Content }
## model is an IDREF
Reset.Attributes &=
    Common.Attributes,
    attribute model { xsd:NCName },
    Events.Attributes
Reset.Content = empty

Insert = element insert { Insert.Attributes, Insert.Content }
Insert.Attributes &=
    Common.Attributes,
    attribute at { xsd:string },
    attribute position { "before" | "after" },
    Nodeset.Binding.Attributes?,
    Events.Attributes
Insert.Content = empty

Delete = element delete { Delete.Attributes, Delete.Content }
Delete.Attributes &=
    Common.Attributes,
    attribute at { xsd:string },
    Nodeset.Binding.Attributes?,
    Events.Attributes
Delete.Content = empty

Setindex = element setindex { Setindex.Attributes, Setindex.Content }
## repeat is an IDREF
Setindex.Attributes &=
    Common.Attributes,
    attribute repeat { xsd:NCName },
    attribute index { xsd:string },
    Events.Attributes
Setindex.Content = empty

Toggle = element toggle { Toggle.Attributes, Toggle.Content }
## case is an IDREF
Toggle.Attributes &=
    Common.Attributes,
    attribute case { xsd:NCName },
    Events.Attributes
Toggle.Content = empty

Message = element message { Message.Attributes, Message.Content }
Message.Attributes &=
    Common.Attributes,
    attribute level { "ephemeral" | "modeless" | "modal" },
    Linking.Attributes?,
    Single.Node.Binding.Attributes?,
    Events.Attributes
Message.Content = UI.Inline.Content

Actions = (Action | Dispatch | Rebuild | Recalculate | Refresh | Setfocus | Load | Setvalue | Send | Reset | Insert | Delete | Setindex | Toggle | Message)*

   # Advanced User Interface
Repeat = element repeat { Repeat.Attributes, Repeat.Content }
Repeat.Attributes &=
    Common.Attributes,
    Nodeset.Binding.Attributes,
    UI.Common.Attributes,
    attribute startindex { xsd:positiveInteger }?,
    attribute number { xsd:nonNegativeInteger }?
Repeat.Content =  (Form.Controls | Group | Repeat | UI.Inline.Content)*

Group = element group { Group.Attributes, Group.Content }
Group.Attributes &=
    Common.Attributes,
    Single.Node.Binding.Attributes?,
    UI.Common.Attributes
Group.Content = Label?, (Form.Controls | Group | Repeat | Switch | UI.Inline.Content)*

Switch = element switch { Switch.Attributes, Switch.Content }
Switch.Attributes &=
    Common.Attributes,
    Single.Node.Binding.Attributes?,
    UI.Common.Attributes
Switch.Content = Case+

Case = element case { Case.Attributes, Case.Content }
Case.Attributes &=
    Common.Attributes
Case.Content = Label?, (Form.Controls | Group | Repeat | Switch | UI.Inline.Content)*
@


1.11
log
@Changed
Case.Content = Label?, (Form.Controls | Group | Repeat | Switch |)+
to
Case.Content = Label?, (Form.Controls | Group | Repeat | Switch | UI.Inline.Content)*

because empty case content is useful.
@
text
@d308 1
a308 2
    attribute resource { xsd:anyURI }?,
    Single.Node.Binding.Attributes?,
@


1.10
log
@Changed
Group.Content = Label?, (Form.Controls | Group | Repeat | Switch | UI.Inline.Content)*
to
Group.Content = Label?, (Form.Controls | Group | Repeat | Switch)*
@
text
@d410 1
a410 1
Case.Content = Label?, (Form.Controls | Group | Repeat | Switch)+
@


1.9
log
@Chnged
Repeat.Content =  (Form.Controls | Group | Repeat )*
 to
Repeat.Content =  (Form.Controls | Group | Repeat | UI.Inline.Content)*
though the host language really should be responsible for this instead.
@
text
@d398 1
a398 1
Group.Content = Label?, (Form.Controls | Group | Repeat | Switch)*
@


1.8
log
@Changed
 Load.Attributes
to have
    attribute resource { xsd:anyURI },
instead of
    attribute resource { xsd:anyURI }?,
@
text
@d391 1
a391 1
Repeat.Content =  (Form.Controls | Group | Repeat)*
@


1.7
log
@I would like to have the Label.Content model be updated by the host language.
I found I had to re-order the Label.Content definition and change the Label definition to use an explicit mention of the attributes and content in order to express that a Label can have either content or (one of linking or binding) attributes, but still keep the Common attributes.

Someone please help me express that constraint without having to ditch the Label.Attributes.

Changed
Label.Content = UI.Inline.Content
Label = element label { Label.Attributes, Label.Content }
Label.Attributes &=
    Common.Attributes,
    Linking.Attributes?,
    Single.Node.Binding.Attributes?

to

Label.Content = UI.Inline.Content
Label = element label { Common.Attributes & (Linking.Attributes | Single.Node.Binding.Attributes | Label.Content) }
#Label.Attributes &=
#    Common.Attributes,
#    Linking.Attributes?,
#    Single.Node.Binding.Attributes?
@
text
@d308 1
a308 1
    attribute resource { xsd:anyURI },
@


1.6
log
@Change
UI.Inline.Content = text & Output?
to
UI.Inline.Content = (text & Output?)
@
text
@a87 5
Label = element label { Label.Attributes, Label.Content }
Label.Attributes &=
    Common.Attributes,
    Linking.Attributes?,
    Single.Node.Binding.Attributes?
d89 5
@


1.5
log
@on Submission.Attribyutes, changed
    attribute bind { xsd:NCName }?,

to
    (attribute bind { xsd:NCName } | attribute ref { xsd:string })?,

because it wasn't allowing ref on submission, and you can have only ref or bind.
@
text
@d84 1
a84 1
UI.Inline.Content = text & Output?
@


1.4
log
@Changed
 to
# Placeholder for XML Schema RNG
Schema = element xsd:schema { (attribute * { text } | text | anyElement)* }*

and then allowed Schema* in Model.

I don't know the magic in RNG for saying to use a RNG Schema for the element if one is available but otherwise allow it.
I suspect the right thing to do is to move the xsd:schema content model out into another file, which be provided by the host.
@
text
@d53 1
a53 1
    attribute bind { xsd:NCName }?,
@


1.3
log
@Removed
 start = Model | Group | Switch | Repeat | Input | Secret | Textarea | Output | Upload | Range | Select1 | Select | Trigger | Submit
because the host language should be responsible for determining where XForms elements can be placed.
@
text
@d31 3
d40 1
a40 1
Model.Content = Instance* & Submission* & Bind* & element xsd:schema { (attribute * { text } | text | anyElement)* }* & Actions*
@


1.2
log
@remove include "xmlhost.rnc" # simulate host-language addition of ID attributes, etc.
because the host should include xforms.rnc, not vice versa.
@
text
@a20 1
start = Model | Group | Switch | Repeat | Input | Secret | Textarea | Output | Upload | Range | Select1 | Select | Trigger | Submit
@


1.1
log
@Initial revision
@
text
@a19 1
include "xmlhost.rnc" # simulate host-language addition of ID attributes, etc.
@
